"""Implementation of the ``varfish_export_step``

This step processes variant call and quality control information output of other pipeline
steps and prepares them for import into VarFish via ``varfish-cli``.

==========
Properties
==========

overall stability

    **stable**

applicable to

    germline alignment and variant calling data

generally applicable to

    short read DNA sequencing

==========
Step Input
==========

The step will read in

- quality control data from ``ngs_mapping``
- variant call output data from ``variant_calling`` and ``sv_calling_targeted``

===========
Step Output
===========

TODO

=============
Configuration
=============

By default, input from ``ngs_mapping`` and ``variant_calling`` is enabled by setting the
appropriate input paths.

You should enable ``sv_calling_targeted`` or ``sv_calling_wgs`` if you used the corresponding
steps (and have the corresponding data types).

=====================
Default Configuration
=====================

The default configuration is as follows. Note that the ``path_jannovar_ser`` parameter must
be set to point to the desired transcript annotations db as generated by ``jannovar download``.

.. include:: DEFAULT_CONFIG_varfish_export.rst
"""

from itertools import chain
import re
import typing
import warnings

from biomedsheets.shortcuts import GermlineCaseSheet, is_not_background, Pedigree
from matplotlib.cbook import flatten
from snakemake.io import Wildcards, expand

from snappy_pipeline.utils import DictQuery, dictify, listify
from snappy_pipeline.workflows.abstract import (
    BaseStep,
    BaseStepPart,
    LinkOutStepPart,
    ResourceUsage,
    WritePedigreeStepPart,
)
from snappy_pipeline.workflows.abstract.common import SnakemakeDict, SnakemakeDictItemsGenerator
from snappy_pipeline.workflows.abstract.warnings import InconsistentPedigreeWarning
from snappy_pipeline.workflows.ngs_mapping import NgsMappingWorkflow
from snappy_pipeline.workflows.sv_calling_targeted import SvCallingTargetedWorkflow
from snappy_pipeline.workflows.variant_calling import (
    VariantCallingGetLogFileMixin,
    VariantCallingWorkflow,
)

__author__ = "Manuel Holtgrewe <manuel.holtgrewe@bih-charite.de>"

#: Extension of files
EXTS = (".tsv.gz", ".tsv.gz.md5")

#: Infixes to use for file name generation
INFIXES = ("gts", "db-infos", "bam-qc")

# TODO: the number of restart times is high because tabix in HTSJDK/Jannovar is flaky...

#: Default configuration for the somatic_variant_calling step
DEFAULT_CONFIG = r"""
# Default configuration varfish_export.
step_config:
  varfish_export:
    # Configuration of the input path enables export from the corresponding pipeline step.
    #
    # Used output of ngs_mapping is alignment quality control data
    path_ngs_mapping: ../ngs_mapping
    # Used output of variant_calling is variant calls
    path_variant_calling: ../variant_calling
    # Used output of targeted SV calling is variant calls
    path_sv_calling_targeted: null  # REQUIRED; optional
    # Used output of WGS SV calling is variant calls
    path_sv_calling_wgs: null       # REQUIRED; optional

    # Optionally, you can override the exported mappers and variant callers by setting
    # the following variables.
    tools_ngs_mapping: null
    tools_variant_calling: null
    tools_sv_calling_targeted: null
    tools_sv_calling_wgs: null

    # The following configuration is used for parameterizing the output itself.
    #
    # The release of the genome reference that data has been aligned to.
    release: GRCh37              # REQUIRED: default 'GRCh37'
    # Path to BED file with exons; used for reducing WGS data to near-exon small variants.
    path_exon_bed: REQUIRED      # REQUIRED: exon BED file to use when handling WGS data
    # Path to Jannovar RefSeq ``.ser`` file for annotation
    path_refseq_ser: REQUIRED    # REQUIRED: path to RefSeq .ser file
    # Path to Jannovar ENSEMBL ``.ser`` file for annotation
    path_ensembl_ser: REQUIRED   # REQUIRED: path to ENSEMBL .ser file
    # Path to VarFish annotator database file to use for annotating.
    path_db: REQUIRED            # REQUIRED: spath to varfish-annotator DB file to use
"""


class VarfishAnnotatorAnnotateStepPart(VariantCallingGetLogFileMixin, BaseStepPart):
    """This step part is responsible for annotating the variants with VarFish Annotator"""

    name = "varfish_annotator"
    actions = ("annotate", "annotate_svs", "bam_qc")

    def __init__(self, parent):
        super().__init__(parent)
        self.base_path_out = (
            "work/{mapper}.{var_caller}.varfish_annotated.{index_ngs_library}/out/.done"
        )
        # Build shortcut from index library name to pedigree
        self.index_ngs_library_to_pedigree = {}
        for sheet in self.parent.shortcut_sheets:
            self.index_ngs_library_to_pedigree.update(sheet.index_ngs_library_to_pedigree)

    def get_input_files(self, action) -> SnakemakeDict:
        self._validate_action(action)
        return getattr(self, f"_get_input_files_{action}")

    def get_output_files(self, action) -> SnakemakeDict:
        self._validate_action(action)
        return getattr(self, f"_get_output_files_{action}")()

    @dictify
    def get_log_file(self, action: str) -> SnakemakeDictItemsGenerator:
        self._validate_action(action)
        prefix = (
            "work/{mapper}.varfish_export.{index_ngs_library}/log/"
            f"{{mapper}}.varfish_annotator_{action}.{{index_ngs_library}}"
        )
        key_ext = (
            ("wrapper", ".wrapper.py"),
            ("log", ".log"),
            ("conda_info", ".conda_info.txt"),
            ("conda_list", ".conda_list.txt"),
            ("env_yaml", ".environment.yaml"),
        )
        for key, ext in key_ext:
            yield key, prefix + ext
            yield key + "_md5", prefix + ext + ".md5"

    def get_params(self, action):
        self._validate_action(action)
        return getattr(self, f"_get_params_{action}")

    def get_resource_usage(self, action: str) -> ResourceUsage:
        self._validate_action(action)
        return ResourceUsage(
            threads=2,
            time="1-00:00:00",
            memory="14G",
        )

    @listify
    def get_result_files(self, action):
        # Generate templates to the output paths from action's result files.
        if action == "annotate":
            raw_path_tpls = self._get_output_files_annotate().values()
        elif action == "annotate_svs":
            # Only annotate SVs if path to step for calling them is configured.
            if (
                not self.parent.config["path_sv_calling_targeted"]
                and not self.parent.config["path_sv_calling_wgs"]
            ):
                return
            raw_path_tpls = self._get_output_files_annotate().values()
        elif action == "bam_qc":
            raw_path_tpls = self._get_output_files_bam_qc().values()
        # Filter the templates to the paths in the output directory.
        path_tpls = [tpl for tpl in flatten(raw_path_tpls) if tpl.startswith("output/")]

        # Create concrete paths for all pedigrees in the sample sheet.
        index_ngs_libraries = self._get_index_ngs_libraries(
            require_consistent_pedigree_kits=(
                bool(self.parent.config["path_sv_calling_targeted"]) and (action == "annotate_svs")
            )
        )
        kwargs = {
            "index_ngs_library": list(index_ngs_libraries.keys()),
            "mapper": [self.parent.config["tools_ngs_mapping"][0]],
        }
        # if action == "annotate":
        #     kwargs["var_caller"] = self.parent.config["tools_variant_calling"]
        # elif action == "annotate_svs" and self.parent.config["path_sv_calling_targeted"]:
        #     kwargs["sv_caller"] = self.parent.config["tools_sv_calling_targeted"]
        for path_tpl in path_tpls:
            yield from expand(path_tpl, **kwargs)

    @dictify
    def _get_index_ngs_libraries(
        self, *, require_consistent_pedigree_kits: bool = False
    ) -> typing.Generator[typing.Tuple[str, typing.List[str]], None, None]:
        """Return ``dict`` that maps the index DNA library name to a list of all pedigree
        member's DNA library names.
        """
        for sheet in filter(is_not_background, self.parent.shortcut_sheets):
            for pedigree in sheet.cohort.pedigrees:
                if not require_consistent_pedigree_kits or self._is_pedigree_good(pedigree):
                    index = pedigree.index.dna_ngs_library.name
                    donors = [
                        donor.dna_ngs_library.name
                        for donor in pedigree.donors
                        if donor.dna_ngs_library
                    ]
                    yield index, donors

    def _is_pedigree_good(self, pedigree: Pedigree) -> bool:
        """Check pedigrees for inconsistencies and issue warning for any.

        :return: ``True`` if there was no inconsistency reported
        """
        msg = None
        donor_names = list(sorted(d.name for d in pedigree.donors))
        if not pedigree.index:  # pragma: no cover
            msg = f"INFO: pedigree without index (name: {donor_names})"
        elif not pedigree.index.dna_ngs_library:  # pragma: no cover
            msg = f"INFO: pedigree index without DNA NGS library (names: {donor_names})"
        if msg:
            warnings.warn(InconsistentPedigreeWarning(msg))
        return not msg

    @dictify
    def _get_input_files_annotate(self, wildcards):
        yield "ped", "work/write_pedigree.{index_ngs_library}/out/{index_ngs_library}.ped"
        tpl = (
            "output/{mapper}.{var_caller}.{index_ngs_library}/out/"
            "{mapper}.{var_caller}.{index_ngs_library}"
        )
        key_ext = {"vcf": ".vcf.gz"}
        variant_calling = self.parent.sub_workflows["variant_calling"]
        for key, ext in key_ext.items():
            yield key, variant_calling(tpl + ext).format(
                mapper=wildcards.mapper,
                var_caller=wildcards.var_caller,
                index_ngs_library=wildcards.index_ngs_library,
            )

    @dictify
    def _get_output_files_annotate(self):
        # Generate paths in "work/" directory
        prefix = (
            "work/{mapper}.varfish_export.{index_ngs_library}/out/"
            "{mapper}.varfish_annotator_annotate.{index_ngs_library}"
        )
        work_paths = {  # annotate will write out PED file
            "ped": f"{prefix}.ped",
            "ped_md5": f"{prefix}.ped.md5",
            "gts": f"{prefix}.gts.tsv.gz",
            "gts_md5": f"{prefix}.gts.tsv.gz.md5",
            "db_infos": f"{prefix}.db-infos.tsv.gz",
            "db_infos_md5": f"{prefix}.db-infos.tsv.gz.md5",
        }
        yield from work_paths.items()
        # Generate paths in "output/" directory
        yield "output_links", [
            re.sub(r"^work/", "output/", work_path)
            for work_path in chain(work_paths.values(), self.get_log_file("annotate").values())
        ]

    def _get_params_annotate(self, wildcards: Wildcards) -> typing.Dict[str, typing.Any]:
        pedigree = self.index_ngs_library_to_pedigree[wildcards.index_ngs_library]
        for donor in pedigree.donors:
            if (
                donor.dna_ngs_library
                and donor.dna_ngs_library.extra_infos.get("libraryType") == "WGS"
            ):
                return {"is_wgs": True, "step_name": "varfish_export"}
        return {"is_wgs": False, "step_name": "varfish_export"}

    @dictify
    def _get_input_files_annotate_svs(self, wildcards):
        yield "ped", "work/write_pedigree.{index_ngs_library}/out/{index_ngs_library}.ped"

        path_tpl = "output/{mapper}.{index_ngs_library}/out/{mapper}.{index_ngs_library}"
        key_ext = {"vcf": ".vcf.gz"}
        if self.parent.config["path_sv_calling_targeted"]:
            sv_calling = self.parent.sub_workflows["sv_calling_targeted"]
        elif self.parent.config["sv_calling_wgs"]:
            sv_calling = self.parent.sub_workflows["sv_calling_wgs"]
        else:
            raise RuntimeError("Neither targeted nor WGS SV calling configured")
        for key, ext in key_ext.items():
            path = f"{path_tpl}{ext}"
            yield key, sv_calling(path).format(
                mapper=wildcards.mapper,
                var_caller=wildcards.var_caller,
                index_ngs_library=wildcards.index_ngs_library,
            )

    @dictify
    def _get_output_files_annotate_svs(self):
        prefix = (
            "work/{mapper}.varfish_export.{index_ngs_library}/out/"
            "{mapper}.varfish_annotator_annotate_svs.{index_ngs_library}"
        )
        work_paths = {
            "gts": f"{prefix}.gts.tsv.gz",
            "gts_md5": f"{prefix}.gts.tsv.gz.md5",
            "feature_effects": f"{prefix}.feature-effects.tsv.gz",
            "feature_effects_md5": f"{prefix}.feature-effects.tsv.gz.md5",
            "db_infos": f"{prefix}.db-infos.tsv.gz",
            "db_infos_md5": f"{prefix}.db-infos.tsv.gz.md5",
        }
        yield from work_paths.items()
        # Generate paths in "output/" directory
        yield "output_links", [
            re.sub(r"^work/", "output/", work_path)
            for work_path in chain(work_paths.values(), self.get_log_file("annotate").values())
        ]

    @dictify
    def _get_input_files_bam_qc(self, wildcards):
        vals = {"mapper": wildcards.mapper, "var_caller": wildcards.var_caller}
        ngs_mapping = self.parent.sub_workflows["ngs_mapping"]
        # Get names of primary libraries of the selected pedigree.  The pedigree is selected
        # by the primary DNA NGS library of the index.
        pedigree = self.index_ngs_library_to_pedigree[wildcards.index_ngs_library]
        result = {"bamstats": [], "flagstats": [], "idxstats": [], "cov_qc": []}
        for donor in pedigree.donors:
            if not donor.dna_ngs_library:
                continue
            tpl = (
                "output/{mapper}.{index_ngs_library}/report/bam_qc/"
                "{mapper}.{index_ngs_library}.bam.%s.txt"
            ).format(**vals, index_ngs_library=donor.dna_ngs_library.name)
            for key in ("bamstats", "flagstats", "idxstats"):
                result[key].append(ngs_mapping(tpl % key))
            if donor.dna_ngs_library.name not in self.parent.ngs_library_to_kit:
                continue
            path = (
                "output/{mapper}.{index_ngs_library}/report/cov_qc/"
                "{mapper}.{index_ngs_library}.txt"
            ).format(**vals, index_ngs_library=donor.dna_ngs_library.name)
            result["cov_qc"].append(ngs_mapping(path))
        return result

    @dictify
    def _get_output_files_bam_qc(self) -> SnakemakeDictItemsGenerator:
        prefix = (
            "work/{mapper}.varfish_export.{index_ngs_library}/out/"
            "{mapper}.varfish_annotator_bam_qc.{index_ngs_library}"
        )
        work_paths = {
            "bam_qc": f"{prefix}.bam-qc.tsv.gz",
            "bam_qc_md5": f"{prefix}.bam-qc.tsv.gz.md5",
        }
        yield from work_paths.items()
        yield "output_links", [
            re.sub(r"^work/", "output/", work_path)
            for work_path in chain(work_paths.values(), self.get_log_file("bam_qc").values())
        ]

    def _get_params_bam_qc(self, wildcards: Wildcards) -> typing.Dict[str, str]:
        """Get parameters for wrapper ``variant_annotator/bam_qc``

        Creates dictionary that links library name to identifier that should be used in output file.
        The wrapper will derive the library name from the input file name, for analysis using
        externally generated data, the values will be the sample name as provided by the external
        source (sample name). For snappy-based analysis it is redundant, both keys and values will
        be the library name.

        Dictionary expected structure:
        {
            "P001-N1-DNA1-WGS1": "P001-N1-DNA1-WGS1",
            "P002-N1-DNA1-WGS1": "P001-N1-DNA1-WGS1",
            "P003-N1-DNA1-WGS1": "P001-N1-DNA1-WGS1",
        }

        :return: Dictionary linking library name to identifier that should be used in output file.
        Key: library name; Value: identifier to be used in file.
        """
        library_name_to_file_identifier = {}
        pedigree = self.index_ngs_library_to_pedigree[wildcards.index_ngs_library]
        for donor in pedigree.donors:
            if donor.dna_ngs_library:
                library_name_to_file_identifier[
                    donor.dna_ngs_library.name
                ] = donor.dna_ngs_library.name
        return library_name_to_file_identifier


class VarfishExportWorkflow(BaseStep):
    """Perform germline variant export to VarFish"""

    name = "varfish_export"
    sheet_shortcut_class = GermlineCaseSheet

    @classmethod
    def default_config_yaml(cls):
        """Return default config YAML, to be overwritten by project-specific one"""
        return DEFAULT_CONFIG

    def __init__(self, workflow, config, config_lookup_paths, config_paths, workdir):
        super().__init__(
            workflow,
            config,
            config_lookup_paths,
            config_paths,
            workdir,
            (VariantCallingWorkflow, SvCallingTargetedWorkflow, NgsMappingWorkflow),
        )

        # Register sub step classes so the sub steps are available
        self.register_sub_step_classes(
            (WritePedigreeStepPart, VarfishAnnotatorAnnotateStepPart, LinkOutStepPart)
        )

        # Register sub workflows
        self.register_sub_workflow("variant_calling", self.config["path_variant_calling"])
        if self.config["path_sv_calling_targeted"]:
            self.register_sub_workflow(
                "sv_calling_targeted", self.config["path_sv_calling_targeted"]
            )
        if self.config["path_sv_calling_wgs"]:
            self.register_sub_workflow("sv_calling_targeted", self.config["path_sv_calling_wgs"])
        self.register_sub_workflow("ngs_mapping", self.config["path_ngs_mapping"])

        # Copy over "tools" setting from variant_calling/ngs_mapping if not set here
        step_config = self.w_config["step_config"]
        if not self.config["tools_ngs_mapping"]:
            self.config["tools_ngs_mapping"] = step_config["ngs_mapping"]["tools"]["dna"]
        if not self.config["tools_variant_calling"] and "variant_calling" in step_config:
            self.config["tools_variant_calling"] = step_config["variant_calling"]["tools"]
        if (
            not self.config["tools_sv_calling_targeted"]
            and "sv_calling_targeted" in self.w_config["step_config"]
        ):
            self.config["tools_sv_calling_targeted"] = step_config["sv_calling_targeted"]["tools"]

        # Build additional information
        self.ngs_library_to_kit = self._build_ngs_library_to_kit()

    @dictify
    def _build_ngs_library_to_kit(self):
        """Build mapping of NGS library to kit based on the ``ngs_mapping`` configuration"""
        cov_config = DictQuery(self.w_config).get("step_config/ngs_mapping/target_coverage_report")
        regexes = {
            item["pattern"]: item["name"]
            for item in cov_config["path_target_interval_list_mapping"]
            if item["name"] != "__default__"
        }
        result = {}
        for sheet in self.shortcut_sheets:
            for donor in sheet.donors:
                for bio_sample in donor.bio_samples.values():
                    for test_sample in bio_sample.test_samples.values():
                        for library in test_sample.ngs_libraries.values():
                            if library.extra_infos.get("libraryKit"):
                                library_kit = library.extra_infos.get("libraryKit")
                                for pattern, name in regexes.items():
                                    if re.match(pattern, library_kit):
                                        yield library.name, name
        return result

    @listify
    def get_result_files(self):
        """Return list of result files for the NGS mapping workflow

        We will process all primary DNA libraries and perform joint calling within pedigrees
        """
        for action in self.sub_steps["varfish_annotator"].actions:
            yield from self.sub_steps["varfish_annotator"].get_result_files(action)

    def check_config(self):
        self.ensure_w_config(
            ("step_config", "varfish_export", "path_ngs_mapping"),
            "Path to ngs_mapping not configured but required for variant annotation",
        )
        self.ensure_w_config(
            ("step_config", "varfish_export", "path_variant_calling"),
            "Path to variant_calling not configured but required for variant annotation",
        )
