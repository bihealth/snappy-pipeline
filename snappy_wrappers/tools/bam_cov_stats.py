#!/usr/bin/env python3
"""Postprocess bedtools coverage output

Given the result of to "bedtools coverage -abam IN.bam -b exons.bed -hist", this program computes
the minimal, mean, and median coverage for each interval.  This result can then be processed into
a report that, e.g., gives the number of exons that have a minimum/mean/median coverage of 10x,
20x, 30x etc.

Note that the exon ids in the BED file must be unique.  This script relies on this in order to
work correctly.
"""

import argparse
import datetime
import sys

__author__ = "Manuel Holtgrewe <manuel.holtgrewe@bihealth.de>"

#: Default value for ``--max-coverage``
DEFAULT_MAX_COVERAGE = 100
#: Default value for ``--step-size``
DEFAULT_STEP_SIZE = 10
#: Default for ``--report``
DEFAULT_REPORT = ("mbc", "amc", "bch")
#: Default for ``--min-cov-warning``
DEFAULT_MIN_COV_WARNING = 20
#: Default for ``--min-cov-ok``
DEFAULT_MIN_COV_OK = 50

#: Allowed choices for ``--report``
CHOICES_REPORT = ("mbc", "amc", "bch", "dec")


class ReportOptions(object):
    """Configuration for building a report."""

    def __init__(self, step_size=10, active_reports=None):
        # report coverage >= nx in steps of self.step_size
        self.step_size = 10
        # maximal coverage to display
        self.max_coverage = 100
        # minimal coverage for reporting WARN label
        self.min_cov_warning = 20
        # minimal coverage for reporting OK label
        self.min_cov_warning = 50
        # activated reports
        self.active_reports = list(active_reports or [])
        # path to BED for display
        self.bed_path = "-"


class Report(object):
    """Hold the report as generated by this program."""

    def __init__(self, options):
        # configuration
        self.options = options
        # total number of intervals
        self.num_intervals = 0
        # mean coverage
        self.mean_coverage = 0.0
        # total target length sum
        self.interval_length_sum = 0
        # min coverage => number of intervals
        self.min_coverage = {}
        # min coverage => number of bases
        self.min_base_coverage = {}
        # file name to use for display
        self.display_file_name = None
        # additional comment lines
        self.comment_lines = []
        # IntervalInfo for all
        self.interval_info_for_all = None
        # IntervalInfo object
        self.interval_infos = []

    def print(self, file):
        """Print the report to the given file."""
        self.print_header(file)
        if "mbc" in self.options.active_reports:
            self.print_minimum_base_coverage(file)
        if "amc" in self.options.active_reports:
            self.print_aggregated_min_coverages(file)
        if "dec" in self.options.active_reports:
            self.print_detailed_exon_reports(file)
        if "bch" in self.options.active_reports:
            self.print_base_coverage_histogram(file)

    def print_base_coverage_histogram(self, file):
        """Print histogram of base coverage."""
        print('# BASE COVERAGE HISTOGRAM (grep for "^BCH", base coverage ' "histogram)", file=file)
        print("#", file=file)
        print("#\tcoverage\tcount", file=file)
        for cov in sorted(self.interval_info_for_all.cov_hist.keys()):
            count = self.interval_info_for_all.cov_hist[cov]
            prefix = "BCH\t"  # base coverage histogram
            values = [prefix, cov, count]
            print("{}{}\t{}".format(*values), file=file)

    def print_header(self, file):
        """Print report header to file."""
        print("# BAM COVERAGE REPORT", file=file)
        print("#", file=file)
        if self.display_file_name:
            print("# for file {}".format(self.display_file_name), file=file)
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print("# created at {}".format(now), file=file)
        print("#", file=file)
        print("# Summary Numbers SN", file=file)
        print("SN\tmean coverage\t{:.2f}".format(self.mean_coverage), file=file)
        print("SN\tBED path\t{}".format(self.options.bed_path), file=file)
        print("SN\tnumber of BED intervals\t{}".format(self.num_intervals), file=file)
        print("SN\ttotal target size\t{}".format(self.interval_length_sum), file=file)
        print("#", file=file)
        if self.comment_lines:
            print("#", file=file)
            for comment in self.comment_lines:
                print("# {}".format(comment))

    def print_minimum_base_coverage(self, file):
        print("#", file=file)
        print('# MINIMUM BASE COVERAGE REPORT (grep for "^MBC", minimal base coverage)', file=file)
        print("#\tmin_cov\tpercentage\tnum_bases", file=file)
        for cov in sorted(self.min_base_coverage.keys()):
            num = self.min_base_coverage[cov]
            prefix = "MBC\t"  # minimal base coverage
            values = [prefix, cov, 0.0, 0]
            if self.num_bases:
                values = [prefix, cov, 100 * num / self.num_bases, num]
            print("{}{}\t{:.2f}\t{}".format(*values), file=file)

    def print_aggregated_min_coverages(self, file):
        """Print report body to file."""
        print("#", file=file)
        print('# MINIMUM COVERAGE REPORT (grep for "^AMC", aggregated min coverage)', file=file)
        print("#\tmin_cov\tpercentage\tnum_intervals", file=file)
        for cov in sorted(self.min_coverage.keys()):
            num = self.min_coverage[cov]
            prefix = "AMC\t"  # exon min coverage
            values = [prefix, cov, 0.0, 0]
            if self.num_intervals:
                values = [prefix, cov, 100 * num / self.num_intervals, num]
            print("{}{}\t{:.2f}\t{}".format(*values), file=file)

    def print_detailed_exon_reports(self, file):
        """Print detailed exon-level report to file."""
        print("#", file=file)
        print(
            '# DETAILED EXON COVERAGE REPORT (grep for "^DEC", detailed '
            "exon coverage, FAIL: <{}, WARNING: <{})".format(
                self.options.min_cov_warning, self.options.min_cov_ok
            ),
            file=file,
        )
        print("#\tname\tlength\tmin_cov\tmax_cov\tmean_cov\tflag", file=file)

        def get_name(info):
            """Helper function that extracts the name from an IntervalInfo."""
            return info.name

        for info in sorted(self.interval_infos.values(), key=get_name):
            prefix = "DEC\t"  # detailed exon coverage
            values = [
                info.name,
                info.end - info.begin,
                info.min_coverage,
                info.max_coverage,
                round(info.mean_coverage, 1),
            ]
            if info.min_coverage < self.options.min_cov_warning:
                values.append("FAIL")
            elif info.min_coverage < self.options.min_cov_ok:
                values.append("WARNING")
            else:
                values.append("OK")
            print("{}{}".format(prefix, "\t".join(map(str, values))), file=file)


class ReportBuilder(object):
    """Builds Report objectgs from ReportOption objects."""

    def __init__(self, report_options):
        self.report_options = report_options

    def build(self, interval_infos, all_info):
        """Return a Report from an iterable of IntervalInfo objects."""
        # compute overall maximal coverage
        def get_min_cov(info):
            return info.min_coverage

        step_size = self.report_options.step_size
        max_cov = 0
        if interval_infos.values():
            max_cov = max(interval_infos.values(), key=get_min_cov).min_coverage
        max_cov = ((max_cov + step_size) // step_size) * step_size
        # allocate list with that many entries
        upper = max(max_cov, self.report_options.max_coverage)
        counters = [0 for i in range(0, upper + 1)]
        # fill counters
        for info in interval_infos.values():
            counters[info.min_coverage] += 1
        # compute partial sums
        for i in reversed(range(0, len(counters) - 1)):
            counters[i] += counters[i + 1]
        # build report
        report = Report(self.report_options)
        report_max = self.report_options.max_coverage + 1
        report.min_base_coverage = self.build_min_base_coverage(all_info)
        report.num_bases = all_info.end
        report.interval_infos = interval_infos
        report.interval_info_for_all = all_info
        for cov in range(0, report_max, step_size):
            report.min_coverage[cov] = counters[cov]
        return report

    def build_min_base_coverage(self, all_info):
        """Build mapping from coverage to number of bases with >= this count"""
        max_cov = max(all_info.cov_hist.keys())
        # allocate list with max_cov entries
        upper = max(max_cov, self.report_options.max_coverage)
        counters = [all_info.cov_hist.get(i, 0) for i in range(0, upper + 1)]
        # compute partial sums
        for i in reversed(range(0, len(counters) - 1)):
            counters[i] += counters[i + 1]
        # write out the values as configured in step_size
        step_size = self.report_options.step_size
        report_max = self.report_options.max_coverage + 1
        result = {}
        for cov in range(0, report_max, step_size):
            result[cov] = counters[cov]
        return result


class IntervalInfo(object):
    """Information stored for each interval/exon in the input file."""

    def __init__(self, name, contig, begin, end):
        """Initialize IntervalInfo

        name -- interval/exon name
        contig -- contig name
        begin -- begin position, 0-based
        end -- end position 0-based
        """
        self.cov_hist = {}
        self.name = name
        self.contig = contig
        self.begin = begin
        self.end = end

    def add_coverage(self, position, coverage):
        """Add coverage information at the given position."""
        self.cov_hist.setdefault(coverage, 0)
        self.cov_hist[coverage] += 1

    def put_histo_entry(self, coverage, count):
        """Writes the histogram entry for coverage to count."""
        self.cov_hist[coverage] = count

    @property
    def mean_coverage(self):
        """Return mean coverage.

        >>> info = IntervalInfo('exon', 'chr1', 0, 20)
        >>> for i in range(0, 20):
        ...     info.add_coverage(i, i // 2)
        >>> info.mean_coverage
        4.5
        """
        base_count = sum(k * v for k, v in self.cov_hist.items())
        return base_count / self.interval_length

    @property
    def interval_length(self):
        """Return interval length.

        >>> info = IntervalInfo('exon', 'chr1', 0, 10)
        >>> info.interval_length
        10
        """
        return self.end - self.begin

    @property
    def min_coverage(self):
        """Return minimal coverage of interval.

        >>> info = IntervalInfo('exon', 'chr1', 0, 10)
        >>> for i in range(0, 10):
        ...     info.add_coverage(i, i // 2)
        >>> info.min_coverage
        0
        """
        return min(self.cov_hist.keys())

    @property
    def max_coverage(self):
        """Return maximal coverage of interval.

        >>> info = IntervalInfo('exon', 'chr1', 0, 10)
        >>> for i in range(0, 10):
        ...     info.add_coverage(i, i // 2)
        >>> info.max_coverage
        4
        """
        return max(self.cov_hist.keys())

    @property
    def median_coverage(self):
        """Return median coverage of interval.

        For this, there has to be a histogram entry for each position in the
        interval.

        Note that the result can be a float even though you input the coverage
        as ints.

        >>> info = IntervalInfo('exon', 'chr1', 0, 10)
        >>> for i in range(0, 10):
        ...     info.add_coverage(i, i // 2)
        >>> info.median_coverage
        2

        >>> info = IntervalInfo('exon', 'chr1', 0, 11)
        >>> for i in range(0, 11):
        ...     info.add_coverage(i, i // 2)
        >>> info.median_coverage
        2

        >>> info = IntervalInfo('exon', 'chr1', 0, 10)
        >>> for i in range(0, 10):
        ...     info.add_coverage(i, i // 5)
        >>> info.median_coverage
        0.5
        """
        num = 0
        if self.interval_length % 2 == 1:  # odd
            for k in sorted(self.cov_hist.keys()):
                if num + self.cov_hist[k] >= self.interval_length // 2 + 1:
                    return k
                num += self.cov_hist[k]
        else:  # even
            low, hi = None, None
            for k in sorted(self.cov_hist.keys()):
                if low is None and (num + self.cov_hist[k] >= self.interval_length // 2):
                    low = k
                if num + self.cov_hist[k] >= self.interval_length // 2 + 1:
                    hi = k
                if low is not None and hi is not None:
                    if hi == low:
                        return hi
                    else:
                        return (hi + low) / 2
                num += self.cov_hist[k]

    def check_hist_size(self):
        """Compare histogram size to the interval length

        Return ``True`` if they have the same size.
        """
        return sum(self.cov_hist.values()) == self.interval_length

    def __str__(self):
        tpl = "IntervalInfo({}, {}:{}-{}, [min={}, median={}, mean={}])"
        return tpl.format(
            self.name,
            self.contig,
            self.begin + 1,
            self.end,
            self.min_coverage,
            self.median_coverage,
            self.mean_coverage,
        )

    def __repr__(self):
        return str(self)


class DataProcessor(object):
    """Processor/buffer that is fed the data from the input."""

    def __init__(self, has_name_col):
        # mapping from interval name (chr, begin, end) to IntervalInfo
        self.interval_infos = {}
        # use column 4 (index 3) as exon name, otherwise use coordinates
        self.has_name_col = has_name_col
        # previous contig
        self.prev_contig = None

    def process_line(self, line):
        """Process a line from the BED input file."""
        arr = line.strip().split("\t")
        if arr[0] == "all":
            key = "__all__"
            if key not in self.interval_infos:
                self.interval_infos[key] = IntervalInfo("all", None, 0, int(arr[3]))
        else:
            contig = arr[0]
            if contig != self.prev_contig:
                print("Now on contig '%s'" % contig, file=sys.stderr)
                self.prev_contig = contig
            if self.has_name_col:
                key = arr[3]  # exon name
            else:
                key = "{}:{}-{}".format(arr[0], arr[1], arr[2])
            if key not in self.interval_infos:
                self.interval_infos[key] = IntervalInfo(key, arr[0], int(arr[1]), int(arr[2]))
        dat = arr[-4:]
        self.interval_infos[key].put_histo_entry(int(dat[0]), int(dat[1]))


def compute_report(args):
    """Compute a Report from an input file."""
    processor = DataProcessor(args.has_name_column)
    for line in args.input_file:
        processor.process_line(line)

    # get overall information
    all_info = None
    if "__all__" in processor.interval_infos:
        all_info = processor.interval_infos["__all__"]
        del processor.interval_infos["__all__"]

    options = ReportOptions()
    options.bed_path = args.bed_path
    options.min_cov_warning = args.min_cov_warning
    options.min_cov_ok = args.min_cov_ok
    options.step_size = args.step_size
    options.max_coverage = args.max_coverage
    options.active_reports = list(args.active_reports)

    report = ReportBuilder(options).build(processor.interval_infos, all_info)
    report.mean_coverage = sum(k * v for k, v in all_info.cov_hist.items()) / sum(
        all_info.cov_hist.values()
    )
    report.num_intervals = len(processor.interval_infos.keys())
    report.interval_length_sum = sum(
        [info.interval_length for info in processor.interval_infos.values()]
    )
    report.display_file_name = args.display_file_name
    report.comment_lines = args.comment_lines
    return report


def parse_args(args=None):
    """Parse arguments"""
    parser = argparse.ArgumentParser(description="coverage report generator")
    parser.add_argument(
        "--bed-path", type=str, default="-", help="path to BED file; for labeling output only"
    )
    parser.add_argument(
        "--input-file",
        type=argparse.FileType("rt"),
        default=sys.stdin,
        help="input file (as written by by bedtools coverage -abam . -b -hist)",
    )
    parser.add_argument(
        "--output-file", type=argparse.FileType("wt"), default=sys.stdout, help="output report file"
    )
    parser.add_argument(
        "--display-file-name", default=None, help="display file name (of the BAM file)"
    )
    parser.add_argument(
        "--comment",
        default=[],
        dest="comment_lines",
        action="append",
        help="additional comment lines",
    )
    parser.add_argument(
        "--max-coverage",
        type=int,
        default=DEFAULT_MAX_COVERAGE,
        help="maximal coverage to display for; default: %d" % DEFAULT_MAX_COVERAGE,
    )
    parser.add_argument(
        "--step-size",
        type=int,
        default=DEFAULT_STEP_SIZE,
        help="step size to use for the computation; default: %d" % DEFAULT_STEP_SIZE,
    )
    parser.add_argument(
        "--report",
        default=list(DEFAULT_REPORT),
        action="append",
        dest="active_reports",
        help=(
            "enabled reports; mbc = minimum base coverage, amc = aggregated mean coverage, "
            "bch = base coverage histogramm, dec = detailed exon coverage; default: %s"
            % (DEFAULT_REPORT,)
        ),
    )
    parser.add_argument(
        "--has-name-column",
        action="store_true",
        dest="has_name_column",
        default=False,
        help="Column 4 in the exons BED file is the name of the column, otherwise use coordinates",
    )

    parser.add_argument(
        "--min-cov-warning",
        default=DEFAULT_MIN_COV_WARNING,
        type=int,
        help="Minimal coverage to issue a warning flag; default: %d" % DEFAULT_MIN_COV_WARNING,
    )
    parser.add_argument(
        "--min-cov-ok",
        default=DEFAULT_MIN_COV_OK,
        type=int,
        help="Minimal coverage to issue an OK flag; default: %d" % DEFAULT_MIN_COV_OK,
    )

    parser.epilog = (
        'Pipe the output of "bedtools intersect" into this tool.  "bedtools intersect" should be '
        "called as follows: bedtools -a exons.bed -b alignment.bam -hist"
    )

    return parser.parse_args(args)


def main(args=None):
    """Main entry point"""
    args = parse_args(args)
    report = compute_report(args)
    report.print(args.output_file)


if __name__ == "__main__":
    sys.exit(main())
